### New
尚未启动的线程处于新建状态。当调用start()方法后，线程进入就绪状态。

### Runnable
在Java虚拟机中执行的线程处于此状态
包括了running和ready两种状态
running状态：线程正在Java虚拟机中执行
ready状态：线程已经启动，但是并没有运行，等待获取CPU资源

### Blocked
线程被阻塞等待监视器锁。例如，当一个线程试图访问同步代码块并且该代码块被其他线程锁定时，该线程就会进入阻塞状态。

### Waiting
线程处于等待状态，它在等待另一个线程执行特定动作。

### Timed Waiting
线程处于等待状态，它在等待另一个线程执行动作达到指定的等待时间。

### Terminated
线程已经退出。

## 线程的生命周期

New：新建状态，线程被创建，但是还没有调用start()方法。

Runnable：可运行状态，线程调用了start()方法，线程进入可运行状态，等待CPU调度。
    
    ready：就绪状态，线程获取到CPU资源，等待CPU调度。
        如果线程调用了sleep(time)方法，线程进入阻塞状态，等待指定时间后，进入就绪状态，等待CPU调度。
        如果线程调用了wait(time)方法，线程进入阻塞状态，等待其他线程调用notify()或者notifyAll()方法，进入就绪状态，等待CPU调度。
        如果线程调用了join(time)方法，线程进入阻塞状态，等待其他线程执行完毕，进入就绪状态，等待CPU调度。
        如果线程调用了parkNanos()方法，线程进入阻塞状态，等待指定时间后，进入就绪状态，等待CPU调度。
        如果线程调用了parkUntil()方法，线程进入阻塞状态，等待指定时间后，进入就绪状态，等待CPU调度。
        
        以上都是属于TimeWaiting状态，只是等待的时间不同。
        
        wait()和sleep()
        如果线程调用了LockSupport.park()方法，线程进入阻塞状态，等待其他线程调用LockSupport.unpark()方法，进入就绪状态，等待CPU调度。
        
        以上都是属于Waiting状态，只是等待的时间不同。
        
        等待进入同步代码块的锁，线程进入阻塞状态，等待其他线程释放锁，进入就绪状态，等待CPU调度。
        以上都是属于Blocked状态，只是等待的时间不同。
    Running：运行状态，CPU开始调度线程，线程开始执行run()方法。

Terminated：终止状态，线程执行完毕，或者因为异常退出了run()方法。

